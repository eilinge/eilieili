# issue

## 优化, 使用redis缓存

    1. 性能, 大量的数据都可以缓存, 大量的读取直接通过redis
        奖品信息, 优惠券信息, 用户抽奖次数...优化处理之后, 将极大的减少对Mysql的读取依赖
        提高该抽奖的高性能, 高并发能力

    2. 原子性操作, redis中的数据递增, 递减操作, 由于mysql中操作
        redis的单进程, 单线程的特点, 到达原子性操作, 避免了并发编程中的线程不安全
        假使直接读取数据库, 还需分布式锁配合数据库更新-- 性能和并发将受到极大的限制

    3. redis缓存属于新增加的冗余数据, 要注意数据更新保持一致性
        空间换时间的方式, 达成了结果; 更新数据的原则: 将旧的数据先清理掉, 再更新数据
        下次读取时, 就会先从数据库中恢复数据到缓存中
        当数据不一致时, 需要手动同步的方法(重新整理缓存的优惠券)

## 创建数据库关联

    1. 数据库连接: connect--"root:tester@tcp(127.0.0.1:3306)/eilieili?charset=utf8"
    2. cd $GOPATH/src/github.com/go-xorm/cmd/xorm
    3. xorm reverse mysql "root:tester@tcp(127.0.0.1:3306)/eilieili?charset=utf8" templates/goxorm 在models目录下生成的数据模型文件

## 产品性能相关(奖品中奖概率, 是通过人为在后台进行设置的)

    更详细的奖品属性

        1. 数量,关于不限量的奖品, 因为每次中奖都发将, 性能会差些

        2. 概率, 预估每天的参与人数, 根据总体奖品数量设置概率

        3. 位置排序, 中奖概率大的放在前面, 如果中奖编码区间会重叠, 则范围小点放在前面, 使程序能更早退出

## 完全的随机还是人为控制发放的节奏

    1. 同一Ip得到多次大奖, 同一用户得到多次大奖, 合理吗?(用户黑名单, ip黑名单)

    2. 奖品集中在一个较短的时间段内全部发放出去, 合理吗?(发奖计划, 奖品池)

    3. 所有用户获得大奖的概率一样, 合理吗?(用户等级)

## 压力测试

    1. 运行的逻辑越少, 性能越好
        减少用户ip抽奖次数
        黑名单
        奖品概率大的放在前面
        ...

    2. 多读取redis缓存, 少读取数据库, 性能越好

    3. 读取/写入数据库会占用大量的时间, 较好的读取性能(~1ms)

    4. 程序循环, 判断, 序列化, 反序列化... 运行逻辑(~2ms)

## 更多的运营策略

## 了解thrift框架

    1. gRPC还比较年轻, 用户和产品基础比较薄

    2. 传统API接口, restful, 使用短连接, 字符序列化效率低

    3. protobuf只是序列化框架, 缺少thrift底层通信的封装

## 项目历程
